- Database script is a file containing a series of SQL commands, designed to create (DDL), modify (DML), or manage (DCL) a database and it's objects (i.e. tables, indexes, etc.).  The reason for these scripts is to automate repetitive database tasks and ensure consistency across different environments.
- Example:
    -- Create a new table (DDL)
    CREATE TABLE users (
        id INT PRIMARY KEY,
        first_name VARCHAR(50),
        last_name VARCHAR(50),
        email VARCHAR(100)
    );

    -- Insert some records (DML)
    INSERT INTO users (id, first_name, last_name, email)
    VALUES (1, 'John', 'Doe', 'john.doe@example.com');

    INSERT INTO users (id, first_name, last_name, email)
    VALUES (2, 'Jane', 'Doe', 'jane.doe@example.com');

    -- Query the table (DQL)
    SELECT * FROM users;

- These scripts can be stored using version control systems (Git).  Create repository for them in GitHub, then upload.
- This database will be a Relational Database.  Made through Postgresql.

- How the Database will look:
    - 5 tables. (Junction tables included in total amount. Minimum of one Junction table. Must have both one-to-one and one-to-many relationships)
    - Appropriate relationship between the tables within the database
- ERD representing the database to be made beforehand.
- Database must be an accurate representation of the ERD.
- Create a relational model as well (i.e. Crows foot notation ERD)
- Tables must be normalised to 3NF minimum.

- Script to create database must include:
    - Tables mapped out by the ERD 
    - Create 'seed' data for each table.  Put simply, populate the tables with data.
    - Query a table for a single record (i.e. SELECT x FROM table;)
    - Query joined tables for a single record (i.e. SELECT a, b, c, d FROM table_1, table_2 WHERE example_id = eg_id;) (Two complex queries)
    - Insert a record into a table (i.e. INSERT INTO table (a, b, c) VALUES ("e", "f", "g");)
    - Insert a record into a table with foreign key data (i.e. Inserting a data from seperate table, such as a unique_id)
    - Update a record in a table (i.e. UPDATE table SET column = value WHERE id = 1;)
    - Delete a record from a table (i.e. DELETE FROM table WHERE id = 3;)
    - Order data by a specific value (i.e. SELECT * FROM table ORDER BY unique_id DESC; or SELECT a, b, c FROM table WHERE location = "x" ORDER BY name;)
    - Calculate data based on values from tables (i.e. SELECT SUM(hours) FROM table WHERE unique_id = 3;) (must use SUM, AVERAGE, MIN, MAX)
    - Filtering data based on a specific value (i.e SELECT * FROM table WHERE name LIKE '%s';)
    - Usage of appropriate automated data creation, such as default or auto-incrementing values (i.e. SERIAL)

    (i.e. SELECT a, b FROM table_1 WHERE id = (SELECT id FROM table_2 WHERE name = "x"))

- Other criteria for top marks:
    - Three functional complex queries that involve selecting, filtering, grouping, and ordering data

- Figure out what integrity checks and constraints for the data model are.  Constraints being 'NOT NULL' when creating the table as an example?


- Database Ideas:
    - Music Streaming Platform Database (i.e Artist, Genres, Record Labels, etc.)
    - Hardware Store or Supermarket (i.e. Employees, Managment, Departments, etc.)
    - Gym (i.e. Managment, Members, Equipment, etc.)
    - Cinema (Employees, Managment, Departments(Tickets, Snacks, Cleaners, etc), Movies, etc.)

- ERD Diagram Notes/Thoughts:
    - Understand how the cardinality in the Crow's Foot Notation ERD works.  Why does the Service table mandatory many characteristic(?), etc.
    - This diagram is referencing the experience of operations that occur in a cinema
    - It's entities are: Movies, Customers, Employees, and Departments
    - The relationships that occur between the entities are: Movies — WATCH — Customers, Customers — SERVICE — Employees, and Employees — BELONG — Departments.
    - In the case of Movies and Customers, I'd argue that in this case, it is a 'one-to-many relationship', as a movie is 'watched' by many customers, but many customers go to 'watch' only one movie (at a time).
    - In the case of Customers and Employees, I'd argue in this case, it is a 'many-to-many relationship', as a customer is 'served' by many employees, and an employee 'serves' many customers.
    - In the case of Employees and Departments, I'd argue in this case, it is a 'one-to-many relationship', as many employees 'belong' to one department, but one employee does not 'belong' to many departments, at once at least (i.e. A person cannot work the ticket booth, be an usher/cinema attendant, operate the projector, clean the theatres, manage the snack booth, etc.).
    - Service_ID serves as the unique key when normalising the data to 2NF.  There is no need for a composite key.
    - Database branches out from Services (however, it is not the first table you enter into the database when seeding data)
    - The Customers table gets broken down further in 3NF as I determined that Membership Status and Membership No. could rely on each other, other than the Customer_ID.  While the 'Yes' status did not rely on the Membership No., the 'No' status did, as 0 was the only value for 'No'.
    - 